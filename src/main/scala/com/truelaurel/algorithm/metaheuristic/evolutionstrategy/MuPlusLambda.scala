package com.truelaurel.algorithm.metaheuristic.evolutionstrategy

import com.truelaurel.algorithm.metaheuristic.model.{Problem, Solution}
import com.truelaurel.time.Stopper

/**
  *
  * @param lambda number of children generated by the parents
  * @param mu     number of parents selected
  */
class MuPlusLambda(mu: Int, lambda: Int, stopper: Stopper) {
  require(lambda > 0)
  require(mu > 0 && mu <= lambda)

  private val parentsRange = 0 until lambda
  private val tweakedRange = 0 until lambda / mu

  def search[S <: Solution](problem: Problem[S]): S = {
    stopper.start()
    var parents = parentsRange
      .map(_ => problem.randomSolution())
      .map(s => (s, s.quality))
      .sortBy(_._2)
      .map(_._1)
    var bestSolution = parents.last
    while (!stopper.willOutOfTime) {
      //truncation selection
      val greatest = parents
        .map(s => (s, s.quality))
        .sortBy(_._2)
        .map(_._1)
        .takeRight(mu)
      bestSolution = if (bestSolution.quality > greatest.last.quality) {
        bestSolution
      } else greatest.last
      parents = greatest ++ greatest.flatMap(s =>
        tweakedRange.map(_ => problem.tweakSolution(s))
      )
    }
    bestSolution
  }

}
